The artifact that I am presenting here is a full stack web application, ‘Travlr’. This application now utilizes Python, and the Flask framework along with PostgreSQL for a database.I used this one artifact to met all the goals and requiremnts of the final project of this class. 

Originally the website was created in my CS 465 a few months ago. Over the course of the semester, we worked to develop it incrementally leading up to a fully functional web application. I used this same approach this semester and worked each week to rebuild the codebase with a new language and database engine and extended its functionality with each iteration. The process was supposed to be “Software Design” then “Data Structures and Algorithms” and finally “databases,” but I found that I had to do the work for the database before the data structure portion due to my development plan. 

In CS 465 we were taught the principles of a full stack application by building this website. At the time we used a JavaScript stack, MEAN, which used MongoDB, Express, Angular and Node for the application. I found this MEAN stack version to be overly complex for a simple application, so for this project I decided to completely rebuild it from the ground up using Python. I did this in hopes to create a cleaner code base while challenging myself and showcasing the skills that I have learned during my time in college. 

When I started to rebuild this web app, I wanted to make sure it was easy to work with locally during development and that the application would be easily shared with others. Because of this, I employed the strategies I've learned in previous classes and used Git to manage the code repository locally and on GitHub remotely. I also created a docker and docker compose file so I could containerize the application locally and be able to allow others with docker to get it up and running easily, should they want to run my application. Docker was not used when originally building this app, so this is a big improvement for anyone looking to run it locally or work with the app in the future. I also have included a simple readme file to help anyone using it get started. With each assignment I practiced techniques that support collaborative environments by using git and GitHub to manage the code base, and by using Docker, and Docker Compose to orchestrate and containerize the application which helps any developer in getting set up.
Once I was set up for success with my development environment, I started to work on the design of the application using the new language, Python. I chose to use Python and the Flask framework to implement the actual server because it is a simple, easy to use framework that is well liked for building APIs. For the first portion of the development cycle, I worked to just recreate the original ‘Travlr’ front end and build the foundation of the API. I also used this portion of the assignment to showcase my abilities as an engineer and my skills in designing software. The initial work for this portion can be found in the in my git repository under the “Part 1-Epress2Flask” branch. I found the Flask implementation to be very clear and easy to extend as I continued to develop the application. 
The required database enhancements for this project allowed me to show off my skills setting up a new database engine for the website. I decided to go with PostgreSQL instead of the original MongoDB because Postgres is a relational database. I felt this would make more sense in the long run for this type of application by allowing strong relationships between any customer data and the trip data in the future. Once I had the Flask server/API setup it was time to get the database connected. Setting up the database was straightforward along with translating the required CRUD database operations from JavaScript. This translation was easy with the use of SQLalchemy, a Python based SQL ORM. Once I finalized all the database enhancements, I pushed all my new code to my GitHub repo under the branch “Part3-Mongo2PosgreSQL”.

Once I had configured the database and all the related functionality was implemented, I started to work on enhancing the functionality of the administrative side of the website by adding a search bar. This search bar was to improve searching and sorting of the data in the database, or more specifically the trips. In this portion I showcased my algorithmic sensibilities and knowledge of working with a given data structure and my ability to use innovative techniques to deliver a valuable solution for a given problem domain.
Here I used techniques to avoid repeated queries on the database for the same data when a user is only sorting the data. I accomplished this by using the front end templating engine Jinja to sort and order the data completely on the client side. This avoids unwanted overhead on the server when doing searches and keeps the query logic very simple. This can be seen in the ‘_trip_listing.html’ file mostly. The search logic against the database can be found in the ‘admin/Trips/trip_routes.py’ file. This is all contained in the “Part2-AddSearch” branch of my GitHub repo. In this enhancement I confidently met the goals of the course where I was to design evaluate computing solutions that solve problems using algorithmic principles with practices and standards appropriate to the solution. 
Lastly I wanted to show off my ability to secure the website. I created a security layer for the website using “Flask-Login” a small extension to flask that adds some security features. This allows me to secure any endpoint that I want with a simple decorator above the endpoints signature. These decorators are visible on the Add, Edit, and Delete Trip endpoints in the trips_routes.py file. Users will be required to first sign up and create an account before being allowed to access these endpoints. I also take measures to protect the user’s password by hashing them before storing them in the database. The authentication functionality is all held in the ‘auth.py’ file. All of this was bundled with the last few commits in my “Part2-AddSearch” branch. I met the course outcomes of having a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources by completing this portion of the enhancements.

This project was a huge learning experience. I did have some basic understanding of Python and using flask, but I greatly expanded my knowledge base of all aspects of web design by working my way through this project. The first segment of the project greatly enhanced my abilities to design a web application. With the Database set up I learned how to configure a PostgreSQL docker container and connect it to my application. Later while creating the search bar I learned a lot about how to pass data around from one page to another and persist the current search data on the client side in a cookie. This allowed me to be able to take advantage of the front-end tools for sorting and ordering the data, as well as be more efficient with my database queries. Implementing the security layer helped me reacquainted myself with security systems and how to prevent access to a website. Building this application has given me a usable template for a broad range of any future client’s needs. 
 
Through the project I did face many challenges, but for the most part things went according to plan. Some of the biggest challenges I faced were during the search bar implementation. I had a hard time figuring out why, when I queried data from the database, I couldn’t immediately serialize the data and store it on the client side. I did a lot of research and found there were a few tricks to solve my problem and I implemented a solution. To solve this problem, I created a “serialize” function that would translate the query result object into a new JSON-like object that was much more easily handled by the application. 

After turning in each portion of the project I did receive some feedback to improve. Most of the feedback was to improve the code clarity by including inline comments or doc strings. I went back and looked through the code and made sure to document any line or process that needed any explanation. I did my best to follow Python’s principles, “Readability counts” and “Simple is better than complex” and cleaned up the code as much as possible. I also incorporated feedback about my documentation and narratives. With the feedback I learned to use a strong voice to show the authority that I have on these subjects now that I have completed my schooling at SNHU.
